Here is a secure React code skeleton based on the provided details:

```jsx
// App.js
import React from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import { AuthProvider } from './auth/AuthContext';
import PrivateRoute from './components/PrivateRoute';
import Login from './pages/Login';
import Dashboard from './pages/Dashboard';
import NotFound from './pages/NotFound';

function App() {
  return (
    <AuthProvider>
      <Router>
        <Switch>
          <Route path="/login" component={Login} />
          <PrivateRoute exact path="/" component={Dashboard} />
          <Route component={NotFound} />
        </Switch>
      </Router>
    </AuthProvider>
  );
}

export default App;

// auth/AuthContext.js
import React, { createContext, useState } from 'react';

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  
  const login = async (credentials) => {
    // Implement secure login logic
    // Validate input
    // Make API call with credentials
    // Store JWT securely
    // Set isAuthenticated to true
  };

  const logout = () => {
    // Clear JWT from storage  
    setIsAuthenticated(false);
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export default AuthContext;

// components/PrivateRoute.js 
import React from 'react';
import { Route, Redirect } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';

const PrivateRoute = ({ component: Component, ...rest }) => {
  const { isAuthenticated } = useAuth();

  return (
    <Route
      {...rest}
      render={(props) =>
        isAuthenticated ? (
          <Component {...props} />
        ) : (
          <Redirect to="/login" />
        )
      }
    />
  );
};

export default PrivateRoute;

// pages/Login.js
import React from 'react';
import { useAuth } from '../auth/AuthContext';

const Login = () => {
  const { login } = useAuth();
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    // Get username and password from form
    // Call login function with credentials
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Render login form */}
    </form>
  );
};

export default Login;

// pages/Dashboard.js
import React from 'react';
import { useAuth } from '../auth/AuthContext';

const Dashboard = () => {
  const { logout } = useAuth();
  
  return (
    <div>
      <h1>Dashboard</h1>
      <button onClick={logout}>Logout</button>
    </div>
  );
};

export default Dashboard;
```

Security Considerations:
1. Input Validation:
   - Validate and sanitize all user inputs on the login form to prevent XSS and injection attacks.

2. Authentication:
   - Implement secure authentication using JWT tokens.
   - Store JWT securely on the client-side (e.g., using secure cookies or local storage).
   - Protect against common authentication attacks like brute-force and credential stuffing.

3. Authorization:  
   - Use `PrivateRoute` component to protect sensitive routes and ensure only authenticated users can access them.

4. Session Management:
   - Implement secure session management using JWT tokens.
   - Set appropriate token expiration times and provide a logout mechanism.

5. Data Protection:
   - Handle sensitive data securely by encrypting it in transit and at rest.
   - Avoid storing sensitive data on the client-side.

6. Error Handling:
   - Implement proper error handling and avoid exposing sensitive information in error messages.

7. Logging:
   - Implement secure logging mechanisms to track important events and detect suspicious activities.

8. API Security:
   - Secure the API endpoints by implementing proper authentication and authorization checks.
   - Use HTTPS to encrypt data in transit.

9. Dependency Security:
   - Keep all dependencies up to date and regularly check for any known vulnerabilities.
   - Use trusted and well-maintained dependencies.

10. Infrastructure Security:
    - Ensure the hosting environment is properly secured and configured.
    - Use security headers like `X-XSS-Protection`, `X-Content-Type-Options`, etc.

User Experience Considerations:
- With a high overall experience score of 95 and low friction score of 5, the user experience seems to be positive. 
- Address the few dead clicks (5) reported in 14% of sessions to further enhance the user experience.
- Analyze the sessions with the lowest experience scores to identify and address any specific issues.

Additional Steps:
- Implement comprehensive security testing, including penetration testing and vulnerability scans.
- Develop security documentation outlining the implemented controls and best practices followed.
- Regularly review and update the security measures to stay proactive against emerging threats.

Remember to tailor the code and security measures based on the specific requirements and context of your application.