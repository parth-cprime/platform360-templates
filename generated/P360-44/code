Based on the provided task details, requirements, user experience insights, and security template, here's a secure code implementation for a React application using JWT authentication:

```jsx
// Authentication.js
import React, { useState } from 'react';
import axios from 'axios';
import jwt from 'jsonwebtoken';

const Authentication = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleLogin = async (e) => {
    e.preventDefault();
    try {
      // Input validation
      if (!username || !password) {
        setError('Please enter both username and password');
        return;
      }

      // Send login request to server
      const response = await axios.post('/api/login', { username, password });

      // Validate JWT token
      const token = response.data.token;
      const decodedToken = jwt.verify(token, process.env.JWT_SECRET);

      // Store token securely
      localStorage.setItem('token', token);

      // Redirect to dashboard or home page
      window.location.href = '/dashboard';
    } catch (error) {
      // Handle errors securely
      console.error('Login error:', error);
      setError('Invalid username or password');
    }
  };

  return (
    <div>
      <h2>Login</h2>
      {error && <p className="error">{error}</p>}
      <form onSubmit={handleLogin}>
        <input
          type="text"
          placeholder="Username"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
        />
        <input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <button type="submit">Login</button>
      </form>
    </div>
  );
};

export default Authentication;
```

Security Controls Implemented:
1. Input Validation: The code validates that both username and password fields are provided before sending the login request to the server.

2. Authentication: The code sends a login request to the server with the provided username and password. The server should implement secure authentication mechanisms, such as hashing and salting passwords.

3. Authorization: The code assumes that the server returns a JWT token upon successful authentication. The token is then validated using the `jwt.verify` function and a secret key stored in an environment variable.

4. Session Management: The JWT token is securely stored in the browser's local storage after successful authentication. This token can be used for subsequent requests to authorize access to protected resources.

5. Data Protection: The code does not directly handle sensitive data. However, it is important to ensure that sensitive data, such as passwords, are properly hashed and stored securely on the server-side.

6. Error Handling: The code handles errors securely by catching exceptions and avoiding the exposure of sensitive information. Generic error messages are displayed to the user.

7. Logging: The code includes a console error log for login errors, which can be helpful for debugging and monitoring purposes. However, it is important to ensure that sensitive information is not logged.

8. API Security: The code assumes that the server implements secure API endpoints for authentication. It is crucial to follow best practices for API security, such as using HTTPS, validating and sanitizing input, and implementing rate limiting.

9. Dependency Security: The code uses the `axios` library for making HTTP requests and the `jsonwebtoken` library for JWT handling. It is important to keep these dependencies up to date and monitor for any security vulnerabilities.

10. Infrastructure Security: The code assumes that the application is deployed in a secure infrastructure environment. This includes using secure server configurations, applying security patches, and following best practices for network security.

Security Documentation:
- The code implements secure authentication using JWT tokens.
- User input is validated before sending requests to the server.
- Errors are handled securely, avoiding the exposure of sensitive information.
- Secure storage of JWT tokens is implemented using local storage.
- The server-side implementation should follow secure authentication practices, such as password hashing and salting.
- API endpoints should be secured using HTTPS, input validation, and rate limiting.
- Dependencies should be kept up to date and monitored for security vulnerabilities.
- The application should be deployed in a secure infrastructure environment.

Security Testing Plan:
- Conduct penetration testing to identify any vulnerabilities in the authentication process.
- Test input validation by attempting to submit invalid or malicious data.
- Verify that errors are handled securely and do not expose sensitive information.
- Test the security of JWT token storage and ensure that tokens are properly validated.
- Perform dependency scanning to identify any known vulnerabilities in the used libraries.
- Conduct regular security audits and updates to ensure the application remains secure.

Note: The provided code focuses on the client-side implementation of authentication. It is crucial to ensure that the server-side implementation follows secure practices as well, such as secure session management, secure storage of user credentials, and proper authorization checks.

Regarding the user experience metrics, the code aims to provide clear error messages to the user in case of authentication failures. This can help address the identified friction and improve the overall user experience. Additionally, implementing secure authentication practices can contribute to a higher overall experience score by ensuring the protection of user data and building trust in the application.