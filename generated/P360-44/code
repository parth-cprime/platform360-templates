Based on the provided task details, requirements, user experience insights, and security template, here's a secure code implementation for a React application with JWT authentication and medium security level:

```jsx
// AuthContext.js
import React, { createContext, useState } from 'react';
import jwt from 'jsonwebtoken';

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);

  const login = async (username, password) => {
    try {
      // TODO: Implement secure authentication API call
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ username, password }),
      });

      if (response.ok) {
        const { token } = await response.json();
        const decodedToken = jwt.decode(token);
        setUser(decodedToken);
        localStorage.setItem('token', token);
      } else {
        throw new Error('Authentication failed');
      }
    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('token');
  };

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

// PrivateRoute.js
import React, { useContext } from 'react';
import { Route, Redirect } from 'react-router-dom';
import { AuthContext } from './AuthContext';

export const PrivateRoute = ({ component: Component, ...rest }) => {
  const { user } = useContext(AuthContext);

  return (
    <Route
      {...rest}
      render={(props) =>
        user ? (
          <Component {...props} />
        ) : (
          <Redirect to={{ pathname: '/login', state: { from: props.location } }} />
        )
      }
    />
  );
};

// SecureComponent.js
import React, { useState } from 'react';

export const SecureComponent = () => {
  const [sensitiveData, setSensitiveData] = useState('');

  const handleInputChange = (e) => {
    const { value } = e.target;
    // TODO: Implement input validation and sanitization
    setSensitiveData(value);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      // TODO: Implement secure data submission API call
      const response = await fetch('/api/secure', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({ sensitiveData }),
      });

      if (!response.ok) {
        throw new Error('Secure data submission failed');
      }
    } catch (error) {
      console.error('Secure data submission error:', error);
      // TODO: Handle error securely
    }
  };

  return (
    <div>
      <h2>Secure Component</h2>
      <form onSubmit={handleSubmit}>
        <input
          type="text"
          value={sensitiveData}
          onChange={handleInputChange}
          placeholder="Enter sensitive data"
        />
        <button type="submit">Submit</button>
      </form>
    </div>
  );
};
```

Security Configuration:
- Use HTTPS for all API calls and data transmission
- Implement strict Content Security Policy (CSP) headers
- Enable CSRF protection on the server-side
- Use secure cookies with HttpOnly and Secure flags
- Implement rate limiting and throttling on API endpoints
- Use secure defaults for libraries and frameworks
- Regularly update dependencies to prevent vulnerabilities

Security Documentation:
- Create a security policy document outlining security practices and guidelines
- Document secure coding practices and standards
- Maintain an incident response plan
- Conduct regular security training for developers

Security Testing Plan:
- Perform static code analysis using tools like ESLint with security plugins
- Conduct manual code reviews focusing on security aspects
- Perform penetration testing and vulnerability assessments
- Implement continuous integration and continuous deployment (CI/CD) with security checks
- Monitor and log application activities for suspicious behavior

Based on the user experience insights, the following optimizations can be considered:
- Investigate and fix the cause of dead clicks to improve user experience
- Analyze sessions with low experience scores to identify and address friction points
- Optimize the application's performance to reduce friction and improve overall experience
- Implement error handling and user-friendly error messages to guide users effectively

Please note that this is a sample implementation and may require further customization based on your specific application requirements. It's essential to thoroughly test and validate the security measures implemented to ensure the application's overall security.