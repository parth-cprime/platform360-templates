Based on the provided information, here is a secure code implementation for a React application with medium security level, JWT authentication, and internal data sensitivity:

```jsx
// App.js
import React from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import { AuthProvider } from './AuthContext';
import Login from './Login';
import Dashboard from './Dashboard';
import PrivateRoute from './PrivateRoute';

function App() {
  return (
    <AuthProvider>
      <Router>
        <Switch>
          <Route path="/login" component={Login} />
          <PrivateRoute path="/" component={Dashboard} />
        </Switch>
      </Router>
    </AuthProvider>
  );
}

export default App;

// AuthContext.js
import React, { createContext, useState } from 'react';
import axios from 'axios';

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState(null);

  const login = async (credentials) => {
    try {
      const response = await axios.post('/api/login', credentials);
      const { token } = response.data;
      localStorage.setItem('token', token);
      setIsAuthenticated(true);
      setUser(response.data.user);
    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    setIsAuthenticated(false);
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export default AuthContext;

// PrivateRoute.js
import React from 'react';
import { Route, Redirect } from 'react-router-dom';
import { useAuth } from './AuthContext';

const PrivateRoute = ({ component: Component, ...rest }) => {
  const { isAuthenticated } = useAuth();

  return (
    <Route
      {...rest}
      render={(props) =>
        isAuthenticated ? (
          <Component {...props} />
        ) : (
          <Redirect to="/login" />
        )
      }
    />
  );
};

export default PrivateRoute;
```

Security Configuration:
- Use HTTPS for secure communication
- Configure CORS settings to restrict access to trusted origins
- Set secure HTTP headers (e.g., X-XSS-Protection, X-Frame-Options)
- Configure Content Security Policy (CSP) to prevent XSS and other attacks
- Use secure cookies with HttpOnly and Secure flags

Security Documentation:
- Document the implemented security controls and their purposes
- Provide guidelines for secure coding practices and code reviews
- Document the authentication and authorization flow
- Include instructions for secure deployment and configuration

Security Testing Plan:
- Perform static code analysis to identify potential vulnerabilities
- Conduct penetration testing to assess the application's security posture
- Perform security testing for OWASP Top 10 vulnerabilities
- Test authentication and authorization scenarios
- Validate input handling and data protection mechanisms

Addressing User Experience Issues:
- Investigate the cause of dead clicks and implement error handling and feedback mechanisms
- Optimize the application's performance to improve overall user experience
- Conduct usability testing to identify and address friction points
- Monitor and analyze user behavior to continuously improve the user experience

Note: The provided code snippets focus on secure authentication and routing. Additional security measures should be implemented based on the specific requirements of the application, such as secure data handling, input validation, and error handling.