Here is a secure React code implementation based on the provided details:

```jsx
// Import necessary dependencies
import React, { useState } from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import jwt from 'jsonwebtoken';
import axios from 'axios';

// Implement secure input validation
function validateInput(input) {
  // Perform input validation and sanitization
  // ...
}

// Implement secure authentication using JWT
function authenticateUser(username, password) {
  // Validate user credentials
  // Generate and sign JWT token
  const token = jwt.sign({ username }, process.env.JWT_SECRET, { expiresIn: '1h' });
  return token;
}

// Implement secure authorization
function authorizeUser(token, requiredRole) {
  try {
    const decodedToken = jwt.verify(token, process.env.JWT_SECRET);
    const userRole = decodedToken.role;
    return userRole === requiredRole;
  } catch (error) {
    console.error('Authorization failed:', error);
    return false;
  }
}

// Implement secure session management
function createSecureSession(token) {
  // Store token securely (e.g., HTTP-only cookie, secure storage)
  // ...
}

// Implement secure data protection
function protectSensitiveData(data) {
  // Encrypt or hash sensitive data
  // Avoid storing sensitive data unnecessarily
  // ...
}

// Implement secure error handling
function handleError(error) {
  console.error('An error occurred:', error);
  // Log error securely
  // Display generic error message to user
  // ...
}

// Implement secure API calls
async function makeSecureApiCall(url, token) {
  try {
    const response = await axios.get(url, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });
    return response.data;
  } catch (error) {
    handleError(error);
    return null;
  }
}

// Implement secure component
function SecureComponent() {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  // Handle authentication
  function handleLogin(username, password) {
    const token = authenticateUser(username, password);
    if (token) {
      createSecureSession(token);
      setIsAuthenticated(true);
    }
  }

  // Handle authorization
  function handleAuthorization(requiredRole) {
    const token = getTokenFromStorage();
    return authorizeUser(token, requiredRole);
  }

  // Render secure content
  return (
    <div>
      {isAuthenticated ? (
        <div>
          {/* Render authenticated content */}
          {/* Implement authorization checks */}
          {handleAuthorization('admin') && <AdminDashboard />}
          {handleAuthorization('user') && <UserProfile />}
        </div>
      ) : (
        <LoginForm onSubmit={handleLogin} />
      )}
    </div>
  );
}

// Implement secure routing
function App() {
  return (
    <Router>
      <Switch>
        <Route path="/" exact component={Homepage} />
        <Route path="/secure" component={SecureComponent} />
        {/* Add more secure routes */}
      </Switch>
    </Router>
  );
}

export default App;
```

Security Configuration:
- Use secure HTTP headers (e.g., HSTS, X-Frame-Options, X-XSS-Protection)
- Configure CSP (Content Security Policy) to restrict content sources
- Enable CSRF protection
- Use secure cookies (HttpOnly, Secure) for session management
- Configure secure headers for API requests
- Implement rate limiting and throttling for API endpoints
- Use secure communication protocols (HTTPS)

Security Documentation:
- Document the implemented security controls
- Provide guidelines for secure usage and configuration
- Include security best practices for developers
- Specify the authentication and authorization mechanisms
- Document the data protection measures
- Outline the error handling and logging procedures
- Provide instructions for reporting security vulnerabilities

Security Testing Plan:
- Perform vulnerability scanning and penetration testing
- Conduct code review to identify security weaknesses
- Test input validation and sanitization
- Verify authentication and authorization mechanisms
- Validate session management and secure storage
- Test error handling and logging functionalities
- Assess the security of dependencies and third-party libraries
- Perform security testing in a controlled environment
- Engage security professionals for thorough testing

Note: The provided code is a simplified example and should be adapted to fit the specific requirements and architecture of your application. It's important to thoroughly test and review the security implementation to ensure its effectiveness.