Based on the provided information, here's an example of secure React code and configuration for your application:

```jsx
// App.js
import React from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import { AuthProvider } from './AuthContext';
import Login from './components/Login';
import PrivateRoute from './components/PrivateRoute';
import Dashboard from './components/Dashboard';

function App() {
  return (
    <AuthProvider>
      <Router>
        <Switch>
          <Route exact path="/login" component={Login} />
          <PrivateRoute exact path="/" component={Dashboard} />
        </Switch>
      </Router>
    </AuthProvider>
  );
}

export default App;
```

```jsx
// AuthContext.js
import React, { createContext, useState } from 'react';

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const login = async (credentials) => {
    // Implement secure authentication logic here
    // Validate user credentials, generate and store JWT securely
    // Set isAuthenticated to true on successful login
    // Handle errors securely
  };

  const logout = () => {
    // Clear authentication state and JWT
    setIsAuthenticated(false);
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};
```

```jsx
// PrivateRoute.js
import React, { useContext } from 'react';
import { Route, Redirect } from 'react-router-dom';
import { AuthContext } from '../AuthContext';

const PrivateRoute = ({ component: Component, ...rest }) => {
  const { isAuthenticated } = useContext(AuthContext);

  return (
    <Route
      {...rest}
      render={(props) =>
        isAuthenticated ? <Component {...props} /> : <Redirect to="/login" />
      }
    />
  );
};

export default PrivateRoute;
```

Security Documentation:
- Implement input validation and sanitization for all user inputs to prevent common vulnerabilities like XSS and SQL injection.
- Use secure authentication mechanisms like JWT (JSON Web Tokens) for user authentication and session management.
- Implement proper authorization checks to ensure users can only access resources they are authorized to access.
- Protect sensitive data by encrypting it in transit (HTTPS) and at rest.
- Handle errors securely and avoid exposing sensitive information in error messages.
- Implement logging to track user actions and detect potential security incidents.
- Secure API endpoints by implementing authentication, authorization, and rate limiting.
- Use secure and up-to-date dependencies and keep them regularly updated.
- Implement security headers and configure security settings appropriately.

Security Testing Plan:
- Perform code review and static analysis to identify potential security vulnerabilities.
- Conduct penetration testing to simulate real-world attacks and identify gaps in security controls.
- Perform security testing of authentication, authorization, and session management mechanisms.
- Test input validation and output encoding to ensure proper handling of user inputs.
- Verify secure handling and storage of sensitive data.
- Test error handling and logging mechanisms to ensure secure behavior.
- Conduct regular security scans and updates to dependencies and configurations.

Based on the user experience insights, consider the following optimizations:
- Investigate and fix the cause of dead clicks to improve user experience and reduce friction.
- Analyze sessions with the lowest experience scores to identify specific issues and areas for improvement.
- Utilize the heatmap to understand user behavior and optimize the user interface accordingly.

Remember to regularly review and update the security controls, conduct security testing, and address any identified vulnerabilities promptly to maintain a secure application.