Based on the provided task details, requirements, and security template, here's a secure implementation of the order management API in React:

```jsx
// securityConfig.js
const securityConfig = {
    helmet: {
        contentSecurityPolicy: {
            directives: {
                defaultSrc: ["'self'"],
                scriptSrc: ["'self'", "'unsafe-inline'"],
                styleSrc: ["'self'", "'unsafe-inline'"],
                imgSrc: ["'self'", "data:", "https:"],
                connectSrc: ["'self'"]
            }
        }
    },
    rateLimit: {
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 100 // limit each IP to 100 requests per windowMs
    },
    cors: {
        origin: process.env.ALLOWED_ORIGINS?.split(',') || [],
        methods: ['GET', 'POST', 'PUT', 'DELETE'],
        credentials: true
    }
};

// authUtils.js
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

const jwtConfig = {
    secret: process.env.JWT_SECRET,
    expiresIn: '1h',
    algorithm: 'HS256'
};

const hashPassword = async (password) => {
    const salt = await bcrypt.genSalt(10);
    return bcrypt.hash(password, salt);
};

const generateToken = (user) => {
    return jwt.sign({ userId: user.id }, jwtConfig.secret, {
        expiresIn: jwtConfig.expiresIn,
        algorithm: jwtConfig.algorithm
    });
};

// inputValidation.js
const Joi = require('joi');

const orderSchema = Joi.object({
    customerId: Joi.string().required(),
    items: Joi.array().items(
        Joi.object({
            productId: Joi.string().required(),
            quantity: Joi.number().integer().min(1).required()
        })
    ).min(1).required(),
    shippingAddress: Joi.object({
        street: Joi.string().required(),
        city: Joi.string().required(),
        zipCode: Joi.string().required()
    }).required()
});

// errorHandler.js
const errorHandler = (err, req, res, next) => {
    console.error(err.stack);
    
    if (err instanceof Joi.ValidationError) {
        return res.status(400).json({
            error: 'Validation Error',
            details: err.details
        });
    }
    
    if (err instanceof jwt.JsonWebTokenError) {
        return res.status(401).json({
            error: 'Authentication Error',
            message: 'Invalid token'
        });
    }
    
    res.status(500).json({
        error: 'Internal Server Error',
        message: 'An unexpected error occurred'
    });
};

// orderRoutes.js
const express = require('express');
const router = express.Router();
const { orderSchema } = require('./inputValidation');
const { generateToken } = require('./authUtils');

router.post('/orders', async (req, res, next) => {
    try {
        await orderSchema.validateAsync(req.body);
        
        // Process the order and save it to the database
        const order = await saveOrder(req.body);
        
        // Generate JWT token
        const token = generateToken(order);
        
        res.status(201).json({ message: 'Order created successfully', token });
    } catch (error) {
        next(error);
    }
});

// app.js
const express = require('express');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cors = require('cors');
const { securityConfig } = require('./securityConfig');
const { errorHandler } = require('./errorHandler');
const orderRoutes = require('./orderRoutes');

const app = express();

// Apply security middleware
app.use(helmet(securityConfig.helmet));
app.use(rateLimit(securityConfig.rateLimit));
app.use(cors(securityConfig.cors));

// Apply order routes
app.use('/api', orderRoutes);

// Error handling middleware
app.use(errorHandler);

// Start the server
app.listen(3000, () => {
    console.log('Server is running on port 3000');
});
```

This implementation incorporates the following security measures:

1. Security Configuration:
   - Content Security Policy (CSP) is set up using the `helmet` middleware to restrict the sources of content.
   - Rate limiting is applied using the `express-rate-limit` middleware to prevent excessive requests from a single IP.
   - CORS is configured to allow requests only from specified origins.

2. Authentication:
   - JWT (JSON Web Token) is used for authentication.
   - The `generateToken` function creates a JWT token with the user's ID as the payload.
   - The token is signed using a secret key and has an expiration time of 1 hour.

3. Input Validation:
   - The `Joi` library is used for input validation.
   - The `orderSchema` defines the expected structure and constraints for the order data.
   - The `orderSchema.validateAsync` method is used to validate the incoming request body against the schema.

4. Error Handling:
   - A centralized error handling middleware (`errorHandler`) is implemented.
   - It handles different types of errors, such as validation errors and authentication errors.
   - Appropriate error responses are sent back to the client based on the error type.

This code provides a starting point for implementing a secure order management API in React. It includes essential security measures like secure configuration, authentication, input validation, and error handling.

Remember to handle additional security aspects like secure communication (HTTPS), secure storage of sensitive data, and proper authentication and authorization mechanisms throughout your application.