Here's the secure Java code for the order management API based on the provided task details, requirements, and security template:

```java
// SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeRequests()
            .antMatchers("/api/public/**").permitAll()
            .antMatchers("/api/orders/**").authenticated()
            .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .oauth2ResourceServer()
            .jwt();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

// JwtTokenProvider.java
@Component
public class JwtTokenProvider {
    
    private final String jwtSecret;
    private final long jwtExpirationInMs;
    
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", userDetails.getAuthorities());
        
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(userDetails.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + jwtExpirationInMs))
            .signWith(SignatureAlgorithm.HS512, jwtSecret)
            .compact();
    }
}

// OrderController.java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @PostMapping
    public ResponseEntity<?> createOrder(@Valid @RequestBody OrderDTO orderDTO) {
        // Implementation for creating an order
    }
    
    @GetMapping("/{orderId}")
    public ResponseEntity<?> getOrder(@PathVariable Long orderId) {
        // Implementation for retrieving an order
    }
    
    // Other order management endpoints
}

// OrderDTO.java
public class OrderDTO {
    @NotBlank(message = "Customer name is required")
    private String customerName;
    
    @NotBlank(message = "Product name is required")
    private String productName;
    
    @Positive(message = "Quantity must be a positive value")
    private int quantity;
    
    // Other order fields
}

// GlobalExceptionHandler.java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(ValidationException ex) {
        ErrorResponse error = new ErrorResponse(
            "Validation Error",
            ex.getMessage(),
            HttpStatus.BAD_REQUEST
        );
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
            "Authentication Error",
            ex.getMessage(),
            HttpStatus.UNAUTHORIZED
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }
}
```

In this code:

1. The `SecurityConfig` class is configured to use OAuth2 with JWT for authentication. It requires authentication for all endpoints under `/api/orders/**` and allows public access to endpoints under `/api/public/**`.

2. The `JwtTokenProvider` class generates JWT tokens with user roles as claims.

3. The `OrderController` class defines the endpoints for order management, such as creating an order (`POST /api/orders`) and retrieving an order (`GET /api/orders/{orderId}`). Input validation is performed using the `@Valid` annotation and the `OrderDTO` class.

4. The `OrderDTO` class defines the structure of the order data transfer object and includes validation annotations to ensure data integrity.

5. The `GlobalExceptionHandler` class handles exceptions related to validation and authentication, providing appropriate error responses.

Note: Make sure to properly secure the `jwtSecret` used for signing the JWT tokens and set an appropriate `jwtExpirationInMs` value based on your security requirements.

Additionally, ensure that sensitive data, such as customer information and order details, are encrypted when stored in the database and transmitted over the network.

Remember to thoroughly test the API endpoints, handle potential security vulnerabilities, and follow secure coding practices throughout the development process.