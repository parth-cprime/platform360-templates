Here is the secure, well-structured code for the order management API based on the provided requirements and templates:

```
README.md
---------

# Order Management API

## Overview
This project implements an order management API that allows creating, retrieving, updating and deleting orders. It follows security best practices and includes features like authentication, authorization, input validation, rate limiting and error handling.

## Folder Structure
- config/
  - db.js
  - security.js
- controllers/
  - orders.js
- middleware/ 
  - auth.js
  - errorHandler.js
  - validate.js
- models/
  - order.js
  - user.js
- routes/
  - orders.js
- services/
  - orders.js
- tests/
  - orders.test.js
- utils/
  - logger.js
- app.js
- package.json

## Key Components

### Controllers
The controllers handle the business logic for the API endpoints. The `orders` controller implements CRUD operations for orders.

### Middleware 
The middleware provides cross-cutting functionality:
- `auth` middleware handles authentication using JWT
- `errorHandler` catches and handles errors 
- `validate` performs request validation using Joi

### Models
The models define the data entities:
- `order` represents an order in the system
- `user` represents an authenticated user

### Routes
The `orders` routes map the controllers to the API endpoints.

### Services  
The `orders` service contains reusable business logic called by the controllers.

### Config
The config files contain configuration:
- `db` configures the database connection
- `security` configures security settings like CORS, CSP, rate limiting

### Utils
The `logger` utility allows consistent logging throughout the application.

## Setup

1. Install dependencies:
   ```
   npm install
   ```

2. Set environment variables:
   ```
   JWT_SECRET=your_jwt_secret
   ALLOWED_ORIGINS=http://localhost:3000,https://yourapp.com
   ```

3. Start the server:
   ```
   npm start
   ```

## Security Considerations
- API endpoints are protected with JWT authentication 
- Passwords are securely hashed before storing
- Input validation is performed using Joi
- Rate limiting middleware prevents abuse
- CORS is configured to allow only trusted origins
- Content Security Policy headers are set
- Errors are handled without exposing sensitive info
- Logging and monitoring should be configured in production

---

config/db.js
------------

// Configure database connection
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB connected');
  } catch (err) {
    console.error(err.message);
    process.exit(1);
  }
};

module.exports = connectDB;

/*
This file configures the MongoDB database connection using Mongoose. It exports a function that connects to the database using the MONGO_URI environment variable.
*/

config/security.js
------------------

// Security middleware configuration
const securityConfig = {
  helmet: {
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"], 
        scriptSrc: ["'self'", "'unsafe-inline'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        imgSrc: ["'self'", "data:", "https:"],
        connectSrc: ["'self'"],
      },
    },
  },
  rateLimit: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
  },
  cors: {
    origin: process.env.ALLOWED_ORIGINS?.split(',') || [],
    methods: ['GET', 'POST', 'PUT', 'DELETE'], 
    credentials: true,
  },
};

module.exports = securityConfig;

/*
This file exports the security configuration for the application. It includes:
- Content Security Policy using the helmet middleware
- Rate limiting to prevent abuse 
- CORS configuration to restrict allowed origins and methods
*/

controllers/orders.js
---------------------

const Order = require('../models/order');
const OrderService = require('../services/orders');

// Create a new order
exports.createOrder = async (req, res, next) => {
  try {
    const { items, total, userId } = req.body;
    const order = await OrderService.createOrder({ items, total, userId });
    res.status(201).json(order);
  } catch (err) {
    next(err);
  }
};

// Get all orders
exports.getOrders = async (req, res, next) => {
  try {
    const orders = await OrderService.getOrders();
    res.json(orders);
  } catch (err) {
    next(err);
  }
};

// Get a single order
exports.getOrder = async (req, res, next) => {
  try {
    const order = await OrderService.getOrderById(req.params.id);
    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }
    res.json(order);
  } catch (err) {
    next(err);
  }
};

// Update an order
exports.updateOrder = async (req, res, next) => {
  try {
    const { items, total } = req.body;
    const order = await OrderService.updateOrder(req.params.id, { items, total });
    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }
    res.json(order);
  } catch (err) {
    next(err);
  }
};

// Delete an order
exports.deleteOrder = async (req, res, next) => {
  try {
    const order = await OrderService.deleteOrder(req.params.id);
    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }
    res.json({ message: 'Order deleted' });
  } catch (err) {
    next(err);
  }
};

/*
This file contains the controller functions for handling CRUD operations on orders. 
It calls the corresponding service functions and sends the appropriate responses.
*/

middleware/auth.js
------------------

const jwt = require('jsonwebtoken');
const User = require('../models/user');

// Authenticate JWT token
exports.authenticateToken = async (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');

  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.userId);

    if (!user) {
      return res.status(401).json({ error: 'Invalid token' });
    }

    req.user = user;
    next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};

/*
This middleware function authenticates the JWT token provided in the Authorization header.
It verifies the token, finds the corresponding user, and attaches it to the request object.
*/

middleware/errorHandler.js 
--------------------------

const logger = require('../utils/logger');

// Error handling middleware
const errorHandler = (err, req, res, next) => {
  logger.error(err.stack);

  if (err.name === 'ValidationError') {
    return res.status(400).json({
      error: 'Validation Error',
      details: err.details,
    });
  }

  if (err.name === 'UnauthorizedError') {
    return res.status(401).json({
      error: 'Authentication Error',
      message: err.message,
    });
  }

  res.status(500).json({
    error: 'Internal Server Error',
    message: 'An unexpected error occurred',
  });
};

module.exports = errorHandler;

/*
This middleware function handles errors that occur in the application. 
It logs the error, and sends an appropriate error response based on the error type.
*/

middleware/validate.js
----------------------

const Joi = require('joi');

// Validate request body against schema
const validateBody = (schema) => {
  return (req, res, next) => {
    const { error } = schema.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }
    next();
  };
};

// Validate request parameters against schema
const validateParams = (schema) => {
  return (req, res, next) => {
    const { error } = schema.validate(req.params);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }
    next();
  };
};

module.exports = {
  validateBody,
  validateParams,
};

/*
This file exports middleware functions for validating request body and parameters using Joi schemas.
The validateBody function validates the request body, while validateParams validates the request parameters. 
If validation fails, a 400 Bad Request response is sent with the validation error details.
*/

models/order.js
---------------

const mongoose = require('mongoose');

const orderSchema = new mongoose.Schema({
  items: [
    {
      name: { type: String, required: true },
      price: { type: Number, required: true },
      quantity: { type: Number, required: true },
    },
  ],
  total: { type: Number, required: true },
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  createdAt: { type: Date, default: Date.now },
});

module.exports = mongoose.model('Order', orderSchema);

/*
This file defines the Mongoose schema and model for an order. 
An order has an array of items, a total price, a reference to the user who placed the order, and a creation timestamp.
*/

models/user.js  
--------------

const mongoose = require('mongoose');
const bcrypt = require('bcrypt');

const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  createdAt: { type: Date, default: Date.now },
});

// Hash password before saving
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) {
    return next();
  }

  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// Compare password for login
userSchema.methods.comparePassword = async function (enteredPassword) {
  return bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

/*
This file defines the Mongoose schema and model for a user.
A user has a username, email, hashed password, and creation timestamp.
The pre-save hook hashes the password before saving, and the comparePassword method compares a plain-text password with the hashed password for login.
*/

routes/orders.js
----------------

const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { validateBody, validateParams } = require('../middleware/validate');
const { createOrder, getOrders, getOrder, updateOrder, deleteOrder } = require('../controllers/orders');
const { createOrderSchema, updateOrderSchema, idParamSchema } = require('../validation/orders');

router.post('/', authenticateToken, validateBody(createOrderSchema), createOrder);
router.get('/', authenticateToken, getOrders);
router.get('/:id', authenticateToken, validateParams(idParamSchema), getOrder);
router.put('/:id', authenticateToken, validateParams(idParamSchema), validateBody(updateOrderSchema), updateOrder);
router.delete('/:id', authenticateToken, validateParams(idParamSchema), deleteOrder);

module.exports = router;

/*
This file defines the Express routes for the order endpoints.
Each route is protected by the authenticateToken middleware to ensure only authenticated users can access them.
Request body and parameters are validated using the corresponding Joi schemas and validation middleware.
The appropriate controller function is called for each route.
*/

services/orders.js
------------------

const Order = require('../models/order');

// Create a new order
exports.createOrder = async (orderData) => {
  const order = new Order(orderData);
  return order.save();
};

// Get all orders
exports.getOrders = async () => {
  return Order.find();
};

// Get a single order by ID
exports.getOrderById = async (id) => {
  return Order.findById(id);
};

// Update an order by ID
exports.updateOrder = async (id, updateData) => {
  return Order.findByIdAndUpdate(id, updateData, { new: true });
};

// Delete an order by ID
exports.deleteOrder = async (id) => {
  return Order.findByIdAndDelete(id);
};

/*
This file contains the service functions for performing CRUD operations on orders.
It interacts with the Order model to create, retrieve, update, and delete orders in the database.
*/

tests/orders.test.js
--------------------

const request = require('supertest');
const app = require('../app');
const Order = require('../models/order');
const User = require('../models/user');
const { connectDB, disconnectDB } = require('./testUtils');

describe('Order API', () => {
  let token;

  beforeAll(async () => {
    await connectDB();
    const user = new User({
      username: 'testuser',
      email: 'test@example.com',
      password: 'password',
    });
    await user.save();
    const res = await request(app).post('/api/auth/login').send({
      username: 'testuser',
      password: 'password',
    });
    token = res.body.token;
  });

  afterAll(async () => {
    await disconnectDB();
  });

  afterEach(async () => {
    await Order.deleteMany();
  });

  describe('POST /api/orders', () => {
    it('should create a new order', async () => {
      const res = await request(app)
        .post('/api/orders')
        .set('Authorization', `Bearer ${token}`)
        .send({
          items: [{ name: 'Item 1', price: 10, quantity: 2 }],
          total: 20,
        });

      expect(res.statusCode).toBe(201);
      expect(res.body).toHaveProperty('_id');
      expect(res.body.items).toHaveLength(1);
      expect(res.body.total).toBe(20);
    });
  });

  describe('GET /api/orders', () => {
    it('should get all orders', async () => {
      const order1 = new Order({
        items: [{ name: 'Item 1', price: 10, quantity: 2 }],
        total: 20,
        userId: '60a5f5e6c3a7a3a7e6e14e8b',
      });
      const order2 = new Order({
        items: [{ name: 'Item 2', price: 15, quantity: 1 }],
        total: 15,
        userId: '60a5f5e6c3a7a3a7e6e14e8b',
      });
      await order1.save();
      await order2.save();

      const res = await request(app)
        .get('/api/orders')
        .set('Authorization', `Bearer ${token}`);

      expect(res.statusCode).toBe(200);
      expect(res.body).toHaveLength(2);
    });
  });

  // Additional tests for other endpoints...
});

/*