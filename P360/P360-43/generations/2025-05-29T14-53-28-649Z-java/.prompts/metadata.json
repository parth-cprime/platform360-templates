{
  "taskId": "P360-43",
  "projectKey": "P360",
  "language": "java",
  "securityLevel": "medium",
  "dataSensitivity": "internal",
  "timestamp": "2025-05-29T14:53:28.650Z",
  "files": [
    "src/main/java/com/company/controller/UserController.java",
    "src/main/java/com/company/model/dto/UserDTO.java",
    "src/main/java/com/company/service/UserService.java",
    "src/main/java/com/company/repository/UserRepository.java",
    "src/main/java/com/company/repository/RoleRepository.java",
    "src/main/java/com/company/model/User.java",
    "src/main/java/com/company/model/Role.java"
  ],
  "prompt": "You are an expert software developer tasked with implementing high-quality code for a Jira task.\n\nTASK DETAILS:\nTask ID: P360-43\nSummary: P360 sample business requirement task\nDescription: Create a order management API where itBackground\n\nThe customer service team currently receives feedback through a web form, but has no automated way to be notified when urgent issues are reported. Team members must regularly check the system, causing delays in addressing time-sensitive customer concerns.\n\nh2. Business Requirement\n\nCreate a notification system that alerts the appropriate customer service team member when customer feedback requiring immediate attention is submitted.\n\nh2. Key Features\n\n# Automatically analyze incoming feedback for urgent keywords or negative sentiment\n# Route notifications to the appropriate team member based on the feedback category\n# Allow team members to acknowledge receipt of notifications\n# Provide a simple dashboard showing pending and acknowledged urgent feedback\n\nh2. Success Criteria\n\n* Urgent feedback notifications are sent within 2 minutes of submission\n* Team members acknowledge receipt of 95% of urgent notifications within 15 minutes during business hours\n* Customer satisfaction for urgent issues improves by 10% within three months is fetching \nStatus: To Do\nPriority: Medium\n\nTECHNICAL REQUIREMENTS:\nLanguage: java\nSecurity Level: medium\nAuthentication Method: jwt\nData Sensitivity: internal\n\nCOMPANY DOMAIN KNOWLEDGE:\n\nDOMAIN EXPERTISE:\n- Domains: retail, e-commerce, outdoor equipment, customer service, inventory management\n- Technologies: react, node.js, mongodb, aws, mobile apps, pos systems\n- Methodologies: agile, scrum, kanban, lean retail\n\nCODING STANDARDS:\n- eslint\n- prettier\n- jest testing\n- responsive design\n\nARCHITECTURE STANDARDS:\n- microservices\n- rest apis\n- event-driven\n- cloud-native\n\nTECHNICAL CONSTRAINTS:\n- must support high seasonal traffic\n- must integrate with existing inventory system\n- must work on all mobile devices\n- must handle real-time inventory updates\n\n\nTEAM CAPABILITIES:\n\nTEAM CAPABILITIES:\n- Skills: react, node.js, retail systems, api development, inventory management\n- Experience Level: e-commerce platforms, retail pos integration, payment processing\n- Certifications: aws solutions architect, scrum master, pci compliance\n\nTEAM HISTORY:\n- inventory-management-system: retail using node.js, mongodb, react\n- mobile-shopping-app: e-commerce using react-native, graphql, stripe\n- omnichannel-loyalty-program: customer retention using node.js, aws, salesforce\n\n\nBUSINESS CONTEXT:\n\nBUSINESS RULES:\n- Naming: product codes must follow CATEGORY-SKU format, branch names must follow feature/JIRA-ID format, apis must use kebab-case\n- Documentation: api endpoints must have swagger documentation, components must have storybook examples, business logic must have unit tests\n- Process: code review required with 2 approvers, regression testing required before release, feature flags for all new functionality, a/b testing for significant ui changes\n\nBUSINESS CONSTRAINTS:\n- release cycles are two weeks\n- holiday code freeze from november 15 to january 10\n- major platform updates quarterly\n\nBUSINESS PREFERENCES:\n- microservices for new development\n- event-driven for inventory updates\n- serverless for batch processing\n- caching layer for product catalog\n- github for source control\n- jira for project management\n- aws for cloud infrastructure\n- datadog for monitoring\n\n\nPROJECT STRUCTURE TEMPLATE: \nThis template MUST be strictly followed for your implementation. Reference this structure for all file paths and organization:\n# Java Project Structure Template\n\n## Project Structure\n```\nproject/\n├── src/main/java/\n│   └── com/company/\n│       ├── controller/     # REST controllers\n│       │   ├── AuthController.java\n│       │   ├── UserController.java\n│       │   └── ApiController.java\n│       ├── model/         # Data models\n│       │   ├── User.java\n│       │   ├── Role.java\n│       │   └── dto/\n│       ├── service/       # Business logic\n│       │   ├── AuthService.java\n│       │   ├── UserService.java\n│       │   └── DataService.java\n│       ├── repository/    # Data access\n│       │   ├── UserRepository.java\n│       │   └── RoleRepository.java\n│       ├── config/        # Configuration\n│       │   ├── SecurityConfig.java\n│       │   └── WebConfig.java\n│       ├── security/      # Security components\n│       │   ├── JwtTokenProvider.java\n│       │   └── SecurityConstants.java\n│       └── exception/     # Exception handling\n│           ├── GlobalExceptionHandler.java\n│           └── CustomException.java\n├── src/main/resources/    # Configuration files\n│   ├── application.properties\n│   └── application-security.properties\n├── src/test/java/         # Test files\n│   ├── controller/\n│   ├── service/\n│   └── security/\n├── pom.xml                # Project dependencies\n└── README.md             # Project documentation\n```\n\n## Required Files\n\n### 1. src/main/java/com/company/config/SecurityConfig.java\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .csrf().disable()\n            .authorizeRequests()\n            .antMatchers(\"/api/public/**\").permitAll()\n            .antMatchers(\"/api/**\").authenticated()\n            .and()\n            .sessionManagement()\n            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);\n    }\n\n    @Bean\n    public JwtAuthenticationFilter jwtAuthenticationFilter() {\n        return new JwtAuthenticationFilter();\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n### 2. src/main/java/com/company/security/JwtTokenProvider.java\n```java\n@Component\npublic class JwtTokenProvider {\n    \n    private final String jwtSecret;\n    private final long jwtExpirationInMs;\n\n    public String generateToken(UserDetails userDetails) {\n        Map<String, Object> claims = new HashMap<>();\n        claims.put(\"roles\", userDetails.getAuthorities());\n        \n        return Jwts.builder()\n            .setClaims(claims)\n            .setSubject(userDetails.getUsername())\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(System.currentTimeMillis() + jwtExpirationInMs))\n            .signWith(SignatureAlgorithm.HS512, jwtSecret)\n            .compact();\n    }\n\n    public boolean validateToken(String token) {\n        try {\n            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token);\n            return true;\n        } catch (Exception ex) {\n            return false;\n        }\n    }\n}\n```\n\n### 3. src/main/java/com/company/controller/ApiController.java\n```java\n@RestController\n@RequestMapping(\"/api\")\npublic class ApiController {\n    \n    @GetMapping(\"/protected\")\n    public ResponseEntity<?> getProtectedData() {\n        return ResponseEntity.ok(new ApiResponse(\"Protected data accessed successfully\"));\n    }\n}\n```\n\n### 4. src/main/java/com/company/service/DataService.java\n```java\n@Service\npublic class DataService {\n    \n    @Autowired\n    private EncryptionService encryptionService;\n\n    public String encryptData(String data) {\n        return encryptionService.encrypt(data);\n    }\n\n    public String decryptData(String encryptedData) {\n        return encryptionService.decrypt(encryptedData);\n    }\n}\n```\n\n### 5. src/main/java/com/company/exception/GlobalExceptionHandler.java\n```java\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(ValidationException.class)\n    public ResponseEntity<ErrorResponse> handleValidationException(ValidationException ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"Validation Error\",\n            ex.getMessage(),\n            HttpStatus.BAD_REQUEST\n        );\n        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);\n    }\n\n    @ExceptionHandler(AuthenticationException.class)\n    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"Authentication Error\",\n            ex.getMessage(),\n            HttpStatus.UNAUTHORIZED\n        );\n        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);\n    }\n}\n```\n\n### 6. src/main/resources/application.properties\n```properties\n# Security properties\njwt.secret=${JWT_SECRET}\njwt.expirationInMs=86400000\n\n# Database properties\nspring.datasource.url=${DB_URL}\nspring.datasource.username=${DB_USERNAME}\nspring.datasource.password=${DB_PASSWORD}\n\n# Logging\nlogging.level.org.springframework.security=DEBUG\n```\n\n## Dependencies (pom.xml)\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>io.jsonwebtoken</groupId>\n        <artifactId>jjwt</artifactId>\n        <version>0.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <optional>true</optional>\n    </dependency>\n</dependencies>\n```\n\n## Security Considerations\n1. Implement proper JWT token validation\n2. Use Spring Security for authentication\n3. Enable CORS with proper configuration\n4. Implement rate limiting\n5. Use security headers\n6. Encrypt sensitive data\n7. Implement proper error handling\n8. Use secure session management\n9. Validate all input data\n10. Implement proper logging\n\n## Best Practices\n1. Follow Spring Security best practices\n2. Use environment variables for sensitive data\n3. Implement proper error handling\n4. Use proper validation annotations\n5. Implement comprehensive testing\n6. Use proper logging\n7. Follow the principle of least privilege\n8. Implement proper session management\n9. Use secure communication protocols\n10. Regular security updates \n\n\nSECURITY REQUIREMENTS TEMPLATE:\nThe following security requirements MUST be implemented based on the specified security level (medium):\n# Java Security Implementation Template\n\n## Security Configuration\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .csrf().disable()\n            .authorizeRequests()\n            .antMatchers(\"/api/public/**\").permitAll()\n            .antMatchers(\"/api/private/**\").authenticated()\n            .and()\n            .sessionManagement()\n            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n            .addFilter(new JwtAuthenticationFilter(authenticationManager()));\n    }\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n## Authentication Implementation\n```java\n@Component\npublic class JwtTokenProvider {\n    \n    private final String jwtSecret;\n    private final long jwtExpirationInMs;\n    \n    public String generateToken(UserDetails userDetails) {\n        Map<String, Object> claims = new HashMap<>();\n        claims.put(\"roles\", userDetails.getAuthorities());\n        \n        return Jwts.builder()\n            .setClaims(claims)\n            .setSubject(userDetails.getUsername())\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(System.currentTimeMillis() + jwtExpirationInMs))\n            .signWith(SignatureAlgorithm.HS512, jwtSecret)\n            .compact();\n    }\n}\n```\n\n## Input Validation\n```java\n@RestController\npublic class UserController {\n    \n    @PostMapping(\"/users\")\n    public ResponseEntity<?> createUser(@Valid @RequestBody UserDTO userDTO) {\n        // Implementation\n    }\n}\n\npublic class UserDTO {\n    @NotBlank(message = \"Username is required\")\n    @Size(min = 3, max = 30, message = \"Username must be between 3 and 30 characters\")\n    private String username;\n    \n    @NotBlank(message = \"Password is required\")\n    @Pattern(regexp = \"^[a-zA-Z0-9]{3,30}$\", message = \"Password must be alphanumeric\")\n    private String password;\n    \n    @NotBlank(message = \"Email is required\")\n    @Email(message = \"Email must be valid\")\n    private String email;\n}\n```\n\n## Error Handling\n```java\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(ValidationException.class)\n    public ResponseEntity<ErrorResponse> handleValidationException(ValidationException ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"Validation Error\",\n            ex.getMessage(),\n            HttpStatus.BAD_REQUEST\n        );\n        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);\n    }\n    \n    @ExceptionHandler(AuthenticationException.class)\n    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"Authentication Error\",\n            ex.getMessage(),\n            HttpStatus.UNAUTHORIZED\n        );\n        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);\n    }\n}\n```\n\n\n\n\nIMPLEMENTATION GUIDELINES:\n1. Use the PROJECT STRUCTURE TEMPLATE as your guide for organizing all code files\n2. Implement ALL the SECURITY REQUIREMENTS appropriate for the specified security level\n3. Include comprehensive error handling, logging, and exception management\n4. Add detailed comments explaining complex logic and important decisions\n5. Implement unit tests for critical functionality\n6. Follow best practices for the specified language and framework\n7. Use modern, clean coding patterns with proper separation of concerns\n\nIMPORTANT: Do NOT just provide implementation instructions or placeholder comments. \nI need COMPLETE, WORKING code with full implementations that can be saved and run.\n\nFILE FORMAT REQUIREMENTS:\nFor each file, provide a clear file path followed by the code content in this format:\n\n```\nFile: src/path/to/filename.extension\n```\n\n```java\n// Full file content here\n```\n\nEnsure each filename is a valid path (e.g., src/components/Auth.tsx) and includes the appropriate extension. \nDo not use descriptions as filenames. Each filename should be a specific path that can be used directly in a filesystem.\n\nIMPORTANT: Provide actual, complete, functional code in all files. Do not include placeholder comments or TODO statements.\n\nIMPLEMENTATION CONSTRAINTS:\n1. Follow the highest security standards based on security level (medium)\n2. Implement appropriate data protection based on sensitivity (internal)\n3. Use proper authentication method (jwt)",
  "parameters": {
    "securityLevel": "medium",
    "authMethod": "jwt",
    "dataSensitivity": "internal"
  },
  "taskDetails": {
    "summary": "P360 sample business requirement task",
    "description": "Create a order management API where itBackground\n\nThe customer service team currently receives feedback through a web form, but has no automated way to be notified when urgent issues are reported. Team members must regularly check the system, causing delays in addressing time-sensitive customer concerns.\n\nh2. Business Requirement\n\nCreate a notification system that alerts the appropriate customer service team member when customer feedback requiring immediate attention is submitted.\n\nh2. Key Features\n\n# Automatically analyze incoming feedback for urgent keywords or negative sentiment\n# Route notifications to the appropriate team member based on the feedback category\n# Allow team members to acknowledge receipt of notifications\n# Provide a simple dashboard showing pending and acknowledged urgent feedback\n\nh2. Success Criteria\n\n* Urgent feedback notifications are sent within 2 minutes of submission\n* Team members acknowledge receipt of 95% of urgent notifications within 15 minutes during business hours\n* Customer satisfaction for urgent issues improves by 10% within three months is fetching ",
    "status": "To Do",
    "priority": "Medium"
  }
}